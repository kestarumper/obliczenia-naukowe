\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tabularx}
\usepackage{polski}
\usepackage{algpseudocode}
\usepackage{algorithm}

\title{Lista 1}
\author{Adrian Mucha 236526}
\date{\today}

\begin{document}

\maketitle

\section{Zadanie 1}
    \subsection{Machine epsilon}
    \subsubsection{Problem}
        Używając języka \texttt{Julia}, napisać program wyznaczający iteracyjnie epsilony maszynowe. Epsilonem maszynowym nazywamy najmniejszą liczbę \textit{macheps} > 0 taką, że \textit{fl(1.0 + macheps) > 1.0} dla każdego typu zmiennopozycyjnego (\texttt{Float16, Float32, Float64)}.
    \subsubsection{Rozwiązanie}
        Znalezienie epsilonu maszynowego opisałem w kilku krokach:
        \begin{enumerate}
            \item przypisz do wybranego typu zmiennej $epsilon = 1.0$
            \item wykonuj dzielenie zmiennej $epsilon$ przez 2 (przesunięcie bitowe w prawo), dopóki $1.0 + epsilon \neq 1.0$
        \end{enumerate}
        Po tym jak pętla zostanie zakończona, w zmiennej $epsilon$ znajdziemy najmniejszą wartość większą od zera - \texttt{macheps}.
        \subsubsection{Wyniki}
        Wyniki zgadzają się z wartościami funkcji wbudowanych oraz tymi zawartymi w pliku nagłówkowym \texttt{float.h}.
        {\small
        \begin{table}[h!]
        \begin{tabularx}{\textwidth}{c X X X}
            \hline
             Typ & $macheps$ & eps(typ) & float.h \\
             \hline
             Float16 & $0.000977$ & 0.000977 & --- \\
             Float32 & $1.1920929e-7$ & $1.1920929e-7$ & $1.192093e-07$ \\
             Float64 & $2.220446049250313e-16$ & $2.220446049250313e-16$ & $2.220446e-16$ \\
             \hline
        \end{tabularx}
        \caption{Wyniki wywołań poszczególnych funkcji dla wybranych typów wraz z danymi z pliku \texttt{float.h} języka C}
        \end{table}
        }
    
    \subsection{Eta}
    \subsubsection{Problem}
        Znaleźć iteracyjnie liczbę \textit{eta} taką, że $eta > 0.0$ dla wszystkich typów zmiennopozycyjnych zgodnych ze standarded \texttt{IEEE 754}.
        \subsubsection{Rozwiązanie}
        \begin{algorithm}
        \caption{Iteracyjne szukanie liczby \textit{eta}}
        \begin{algorithmic}[1]
        \State $x\gets 1.0$
        \While {$x / 2 \neq 0.0$}
            \State $x\gets x / 2$
        \EndWhile \\
        \Return x
        \end{algorithmic}
        \end{algorithm}
        Uzyskana w ten sposób liczba \textit{x} zapisana bitowo w formacie \texttt{Float32} przyjmuje postać następującą:
        \begin{center}
            0 00000000 00000000000000000000001 \\
            = $1.0e-45$
        \end{center}
        Warto wspomnieć, że tego typu liczbę, której \texttt{cechą} są same zera - nazywamy zdenormalizowaną (subnormal).
    \subsubsection{Wyniki}
        {\small
        \begin{table}[h!]
        \centering
        \begin{tabular}{c c c}
            \hline
             Typ & \textit{eta} & \textit{nextfloat(0.0)} \\
             \hline
             Float16 & $6.0e-8$ & $6.0e-8$ \\
             Float32 & $1.0e-45$ & $1.0e-45$\\
             Float64 & $5.0e-324$ & $5.0e-324$\\
             \hline
        \end{tabular}
        \caption{Wartości \textit{eta} według typów zmiennoprzecinkowych}
        \end{table}
        }
    
    \subsection{MAX}
    \subsubsection{Problem}
    \subsubsection{Rozwiązanie}
    \subsubsection{Wyniki}
\end{document}
